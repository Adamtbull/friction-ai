<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Friction AI - Slow down your AI, on purpose</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet" />
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <style>
    /* ... (ALL YOUR EXISTING CSS STAYS EXACTLY THE SAME) ... */
    /* Full CSS from your original file goes here unchanged */
  </style>

</head>

<body>
  <!-- HOMEPAGE -->
  <div class="homepage" id="homepage">
    <div class="brand">FRICTION AI</div>

    <h1 class="headline">Slow down your AI ‚Äî on purpose.</h1>
    <p class="subheadline">Friction AI adds intentional pauses before messages are sent, helping reduce impulsive use and increase presence.</p>

    <div class="section">
      <h2 class="section-title">How it works</h2>
      <ul class="section-list">
        <li>You may be asked to type a short code before sending</li>
        <li>Continued use gradually increases the effort across 7 levels</li>
        <li>It caps at 10 characters and resets after 2 hours</li>
      </ul>
    </div>

    <div class="section">
      <h2 class="section-title">Why</h2>
      <p class="section-subtitle">Tough love, not punishment.</p>
      <p class="section-text">We slow things down because we care about attention, presence, and real-world goals.</p>
    </div>

    <div class="section">
      <h2 class="section-title">Our philosophy</h2>
      <p class="philosophy-line">Ease creates dependency.</p>
      <p class="philosophy-line">Thoughtful friction creates awareness.</p>
      <p class="philosophy-line">We optimise for presence, not engagement.</p>
    </div>

    <div class="divider"></div>

    <div class="cta-section">
      <h2 class="section-title">Try it</h2>
      <p class="cta-text">By continuing, you're choosing a slower AI experience.</p>

      <div class="auth-buttons">
        <button class="btn-oauth" id="btnApple" type="button">
          <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
            <path d="M18.71 19.5c-.83 1.24-1.71 2.45-3.05 2.47-1.34.03-1.77-.79-3.29-.79-1.53 0-2 .77-3.27.82-1.31.05-2.3-1.32-3.14-2.53C4.25 17 2.94 12.45 4.7 9.39c.87-1.52 2.43-2.48 4.12-2.51 1.28-.02 2.5.87 3.29.87.78 0 2.26-1.07 3.81-.91.65.03 2.47.26 3.64 1.98-.09.06-2.17 1.28-2.15 3.81.03 3.02 2.65 4.03 2.68 4.04-.03.07-.42 1.44-1.38 2.83M13 3.5c.73-.83 1.94-1.46 2.94-1.5.13 1.17-.34 2.35-1.04 3.19-.69.85-1.83 1.51-2.95 1.42-.15-1.15.41-2.35 1.05-3.11z"/>
          </svg>
          Continue with Apple
        </button>

        <button class="btn-oauth" id="btnGoogle" type="button">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Continue with Google
        </button>
      </div>

      <button class="btn-primary" id="btnEmail" type="button">Sign in with email</button>

      <!-- Hidden Google Sign-In button -->
      <div id="googleButtonHidden" style="position: absolute; opacity: 0; pointer-events: none; height: 0; overflow: hidden;"></div>

      <p class="footer-note">Works best in your browser. Home-screen optional.</p>
    </div>
  </div>

  <!-- CHAT APPLICATION -->
  <div class="chat-app" id="chatApp">
    <header class="chat-header">
      <div class="chat-header-left">
        <button class="btn-icon" id="btnMenu" title="Menu" type="button">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <line x1="3" y1="6" x2="21" y2="6"/>
            <line x1="3" y1="12" x2="21" y2="12"/>
            <line x1="3" y1="18" x2="21" y2="18"/>
          </svg>
        </button>
      </div>
      <div class="chat-header-center">
        <select class="model-select" id="modelSelect">
          <option value="gemini">Google Gemini 2.5 (Free)</option>
          <option value="claude">Claude Sonnet 4.5 üîí</option>
          <option value="gpt">GPT-4o üîí</option>
          <option value="grok">Grok 3 üîí</option>
          <option value="perplexity">Perplexity Sonar üîí</option>
        </select>
      </div>
      <div class="chat-header-right">
        <div class="header-timer" id="headerTimer"></div>
      </div>
    </header>

    <div class="chat-messages" id="chatMessages">
      <div class="chat-background-goal" id="chatBackgroundGoal"></div>
      <div class="welcome-message">
        <div class="welcome-icon">‚ú¶</div>
        <h2>How can I help you today?</h2>
        <p>Remember: slow is intentional.</p>
      </div>
    </div>

    <div class="typing-indicator" id="typingIndicator">
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
    </div>

    <div class="chat-input-area">
      <div class="chat-input-wrapper">
        <textarea class="chat-input" id="messageInput" placeholder="Message..." rows="1"></textarea>
        <button class="btn-send" id="btnSend" type="button" aria-label="Send message">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M5 12h14M12 5l7 7-7 7"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <!-- SIDE MENU -->
  <div class="menu-overlay" id="menuOverlay"></div>
  <div class="side-menu" id="sideMenu">
    <div class="menu-header">
      <div class="menu-profile" id="menuProfile">
        <img class="profile-pic" id="profilePic" src="" alt="Profile" />
        <div class="profile-info">
          <span class="profile-name" id="profileName"></span>
          <span class="profile-email" id="profileEmail"></span>
        </div>
      </div>
      <button class="btn-close-menu" id="btnCloseMenu" type="button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"/>
          <line x1="6" y1="6" x2="18" y2="18"/>
        </svg>
      </button>
    </div>

    <div class="menu-content">
      <button class="menu-btn-new" id="btnNewChat" type="button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="5" x2="12" y2="19"/>
          <line x1="5" y1="12" x2="19" y2="12"/>
        </svg>
        New Chat
      </button>

      <div class="menu-section">
        <div class="menu-section-title">History</div>
        <div id="chatHistoryList">
          <div class="menu-empty">No chats yet</div>
        </div>
      </div>

      <div class="menu-divider"></div>

      <div class="menu-section">
        <button class="menu-item" id="btnSettings" type="button">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"/>
            <path d="M12 1v4M12 19v4M4.22 4.22l2.83 2.83M16.95 16.95l2.83 2.83M1 12h4M19 12h4M4.22 19.78l2.83-2.83M16.95 7.05l2.83-2.83"/>
          </svg>
          <span>Settings</span>
        </button>
        <button class="menu-item" id="btnAbout" type="button">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="16" x2="12" y2="12"/>
            <line x1="12" y1="8" x2="12.01" y2="8"/>
          </svg>
          <span>About</span>
        </button>
      </div>
    </div>

    <div class="menu-footer">
      <button class="menu-item menu-item-logout" id="btnSignOut" type="button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
          <polyline points="16 17 21 12 16 7"/>
          <line x1="21" y1="12" x2="9" y2="12"/>
        </svg>
        <span>Sign Out</span>
      </button>
    </div>
  </div>

  <!-- FRICTION OVERLAY -->
  <div class="friction-overlay" id="frictionOverlay">
    <div class="friction-box">
      <h2 class="friction-title">Pause & reflect</h2>
      <p class="friction-subtitle">Type the code to send.</p>

      <div class="friction-goal-reminder" id="frictionGoalReminder"></div>

      <div class="friction-row" id="frictionRow1">
        <div class="friction-pair-container" id="frictionPairs1"></div>
      </div>

      <div class="friction-row" id="frictionRow2">
        <div class="friction-pair-container" id="frictionPairs2"></div>
      </div>

      <div class="friction-buttons">
        <button class="btn-cancel" id="frictionCancel" type="button">Cancel</button>
        <button class="btn-unlock" id="frictionUnlock" type="button" disabled>Send message</button>
      </div>

      <p class="friction-timer" id="frictionTimer"></p>
      <p class="friction-error" id="frictionError"></p>
    </div>
  </div>

  <!-- ONBOARDING OVERLAY -->
  <div class="onboarding-overlay" id="onboardingOverlay">
    <div class="onboarding-box">
      <!-- Step 1: Welcome -->
      <div class="onboarding-step active" id="onboardingStep1">
        <div class="onboarding-icon">‚ú¶</div>
        <h2 class="onboarding-title">Welcome to Friction AI</h2>
        <p class="onboarding-text">
          This app adds small moments of pause to help you use AI more intentionally.
        </p>
        <p class="onboarding-text">
          Before we start, let's set some goals. These will gently remind you of what matters most.
        </p>
        <button class="onboarding-btn primary" id="onboardingNext1" type="button">Get Started</button>
      </div>

      <!-- Step 2: Long-term Goal -->
      <div class="onboarding-step" id="onboardingStep2">
        <h2 class="onboarding-title">Your long-term goal</h2>
        <p class="onboarding-text">
          What do you want more of in your life? This will appear softly in the background as you chat.
        </p>
        <textarea 
          class="onboarding-textarea" 
          id="inputLongtermGoal" 
          placeholder="e.g., Be more present with my family, Focus on my mental health, Grow in my career..."
          maxlength="100"
        ></textarea>
        <div class="onboarding-nav">
          <button class="onboarding-btn secondary" id="onboardingBack2" type="button">Back</button>
          <button class="onboarding-btn primary" id="onboardingNext2" type="button">Next</button>
        </div>
      </div>

      <!-- Step 3: Short-term Goals -->
      <div class="onboarding-step" id="onboardingStep3">
        <h2 class="onboarding-title">Your short-term goals</h2>
        <p class="onboarding-text">
          What would you like to focus on today or this week? These will appear when you send messages.
        </p>
        <div class="shortterm-goals-list" id="shorttermGoalsList">
          <input type="text" class="shortterm-goal-input" placeholder="e.g., Study for exam" maxlength="60" />
        </div>
        <button class="onboarding-btn-add" id="addShorttermGoal" type="button">+ Add another goal</button>
        <div class="onboarding-nav">
          <button class="onboarding-btn secondary" id="onboardingBack3" type="button">Back</button>
          <button class="onboarding-btn primary" id="onboardingNext3" type="button">Finish</button>
        </div>
      </div>

      <!-- Step 4: All Set -->
      <div class="onboarding-step" id="onboardingStep4">
        <div class="onboarding-icon">üéØ</div>
        <h2 class="onboarding-title">You're all set!</h2>
        <p class="onboarding-text">
          Your goals are saved. You can update them anytime from the menu.
        </p>
        <div class="onboarding-summary" id="onboardingSummary"></div>
        <button class="onboarding-btn primary" id="onboardingFinish" type="button">Start Chatting</button>
      </div>
    </div>
  </div>

  <!-- GOAL CHECK-IN OVERLAY -->
  <div class="onboarding-overlay" id="goalCheckinOverlay">
    <div class="onboarding-box">
      <div class="onboarding-icon">üëã</div>
      <h2 class="onboarding-title">Quick check-in</h2>
      <p class="onboarding-text">
        It's been a little while. Have you made progress on your goals?
      </p>
      <div class="checkin-goals-list" id="checkinGoalsList"></div>
      <div class="onboarding-nav">
        <button class="onboarding-btn secondary" id="checkinSkip" type="button">Skip for now</button>
        <button class="onboarding-btn primary" id="checkinSave" type="button">Save & Continue</button>
      </div>
    </div>
  </div>

  <!-- SETTINGS OVERLAY -->
  <div class="settings-overlay" id="settingsOverlay">
    <div class="settings-box">
      <div class="settings-header">
        <h2 class="settings-title">Settings</h2>
        <button class="settings-close" id="settingsClose" type="button">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>
      </div>

      <div class="settings-lock-banner" id="settingsLockBanner" style="display: none;">
        <span class="lock-icon">üîí</span>
        <span class="lock-text">Settings locked for <span id="lockTimeRemaining">--:--:--</span></span>
      </div>

      <div class="settings-content" id="settingsContent">
        
        <!-- Friction Mode -->
        <div class="settings-section">
          <h3 class="settings-section-title">Friction Mode</h3>
          <p class="settings-section-desc">Choose how much friction to add before sending messages</p>
          
          <label class="settings-radio">
            <input type="radio" name="frictionMode" value="off" />
            <span class="radio-label">
              <strong>Off</strong>
              <span class="radio-desc">No verification needed</span>
            </span>
          </label>
          
          <label class="settings-radio">
            <input type="radio" name="frictionMode" value="light" />
            <span class="radio-label">
              <strong>Light</strong>
              <span class="radio-desc">Goal reminder only, no typing</span>
            </span>
          </label>
          
          <label class="settings-radio">
            <input type="radio" name="frictionMode" value="full" checked />
            <span class="radio-label">
              <strong>Full</strong>
              <span class="radio-desc">Goal reminder + typing code (4-10 chars)</span>
            </span>
          </label>

          <label class="settings-radio strict-mode">
            <input type="radio" name="frictionMode" value="strict" />
            <span class="radio-label">
              <strong>‚ò†Ô∏è Strict Mode</strong>
              <span class="radio-desc">No mercy. 15 levels, up to 2 rows of 20 characters. Take no prisoners.</span>
            </span>
          </label>
        </div>

        <!-- Message Delay -->
        <div class="settings-section" id="messageDelaySection">
          <h3 class="settings-section-title">Message Delay</h3>
          <p class="settings-section-desc">Add a waiting period before messages send</p>
          <p class="settings-section-note" id="delayDisabledNote" style="display: none;">
            ‚ö†Ô∏è Disabled when using Full or Strict friction mode
          </p>
          
          <div id="delayOptions">
            <label class="settings-radio">
              <input type="radio" name="messageDelay" value="0" checked />
              <span class="radio-label"><strong>Off</strong></span>
            </label>
            
            <label class="settings-radio">
              <input type="radio" name="messageDelay" value="5" />
              <span class="radio-label"><strong>5 seconds</strong></span>
            </label>
            
            <label class="settings-radio">
              <input type="radio" name="messageDelay" value="15" />
              <span class="radio-label"><strong>15 seconds</strong></span>
            </label>
            
            <label class="settings-radio">
              <input type="radio" name="messageDelay" value="30" />
              <span class="radio-label"><strong>30 seconds</strong></span>
            </label>
            
            <label class="settings-radio">
              <input type="radio" name="messageDelay" value="45" />
              <span class="radio-label"><strong>45 seconds</strong></span>
            </label>

            <label class="settings-checkbox">
              <input type="checkbox" id="allowCancelDelay" checked />
              <span class="checkbox-label">Allow cancel during countdown</span>
            </label>
          </div>
        </div>

        <!-- Goal Reminders -->
        <div class="settings-section">
          <h3 class="settings-section-title">Goal Reminders</h3>
          
          <label class="settings-checkbox">
            <input type="checkbox" id="showShortTermGoal" checked />
            <span class="checkbox-label">Show short-term goal in friction overlay</span>
          </label>
          
          <label class="settings-checkbox">
            <input type="checkbox" id="showLongTermGoal" checked />
            <span class="checkbox-label">Show long-term goal in chat background</span>
          </label>
        </div>

        <!-- Lock Settings -->
        <div class="settings-section settings-lock-section">
          <h3 class="settings-section-title">üîí Lock Settings</h3>
          <p class="settings-section-desc">Prevent changes for a set period. Once locked, you cannot change settings until the timer expires.</p>
          
          <div class="lock-time-picker">
            <div class="lock-time-row">
              <label class="lock-time-label">Days</label>
              <input type="number" class="lock-time-input" id="lockDays" min="0" max="30" value="0" />
            </div>
            <div class="lock-time-row">
              <label class="lock-time-label">Hours</label>
              <input type="number" class="lock-time-input" id="lockHours" min="0" max="23" value="1" />
            </div>
            <div class="lock-time-row">
              <label class="lock-time-label">Minutes</label>
              <input type="number" class="lock-time-input" id="lockMinutes" min="0" max="59" value="0" />
            </div>
          </div>
          
          <div class="lock-presets">
            <button type="button" class="lock-preset-btn" data-hours="1">1hr</button>
            <button type="button" class="lock-preset-btn" data-hours="4">4hr</button>
            <button type="button" class="lock-preset-btn" data-hours="24">24hr</button>
            <button type="button" class="lock-preset-btn" data-days="3">3 days</button>
            <button type="button" class="lock-preset-btn" data-days="7">1 week</button>
          </div>

          <button class="settings-lock-btn" id="btnLockSettings" type="button">Lock Settings</button>
        </div>
      </div>
    </div>
  </div>

  <!-- MESSAGE DELAY OVERLAY -->
  <div class="delay-overlay" id="delayOverlay">
    <div class="delay-box">
      <div class="delay-countdown" id="delayCountdown">
        <svg class="delay-ring" viewBox="0 0 100 100">
          <circle class="delay-ring-bg" cx="50" cy="50" r="45" />
          <circle class="delay-ring-progress" id="delayRingProgress" cx="50" cy="50" r="45" />
        </svg>
        <span class="delay-time" id="delayTime">5</span>
      </div>
      <p class="delay-text">Sending...</p>
      <p class="delay-hint" id="delayHint">While you wait, you could start on your goal</p>
      <button class="delay-cancel" id="delayCancelBtn" type="button">Cancel</button>
    </div>
  </div>

  <script>
    // STATE
    let state = {
      messages: [],
      pendingMessage: null,
      isProcessing: false,
      currentModel: 'gemini',
      currentChatId: null
    };

    // Constants
    const ADMIN_EMAIL = 'fatboydimsim@gmail.com';
    const FREE_MODELS = ['gemini'];
    const PAID_MODELS = ['claude', 'gpt', 'grok', 'perplexity'];

    // CHAT PERSISTENCE
    function saveChatState() {
      const chatState = {
        messages: state.messages,
        currentModel: state.currentModel,
        currentChatId: state.currentChatId
      };
      localStorage.setItem('friction_chat', JSON.stringify(chatState));
      localStorage.setItem('friction_last_activity', Date.now().toString());
      
      // Also save to history
      saveCurrentChatToHistory();
    }

    function loadChatState() {
      const saved = localStorage.getItem('friction_chat');
      if (saved) {
        try {
          const chatState = JSON.parse(saved);
          state.messages = chatState.messages || [];
          state.currentModel = chatState.currentModel || 'gemini';
          state.currentChatId = chatState.currentChatId || null;
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    }

    function clearChatState() {
      state.messages = [];
      state.currentChatId = null;
      localStorage.removeItem('friction_chat');
    }

    // GOALS MANAGEMENT
    let goals = {
      longterm: '',
      shortterm: [],
      onboardingComplete: false,
      lastGoalCheck: null,
      lastGoalTick: null
    };

    function loadGoals() {
      const saved = localStorage.getItem('friction_goals');
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          goals = Object.assign(goals, parsed);
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    }

    function saveGoals() {
      localStorage.setItem('friction_goals', JSON.stringify(goals));
    }

    function getActiveShortTermGoal() {
      const active = goals.shortterm.filter(g => !g.completed);
      return active.length > 0 ? active[0] : null;
    }

    function shouldShowOnboarding() {
      return !goals.onboardingComplete;
    }

    function shouldShowGoalCheckin() {
      if (!goals.onboardingComplete) return false;
      if (goals.shortterm.length === 0) return false;
      
      // Check if all goals completed
      const allComplete = goals.shortterm.every(g => g.completed);
      if (allComplete) return true;
      
      // Check if 72 hours since last tick
      if (goals.lastGoalTick) {
        const hoursSinceTick = (Date.now() - goals.lastGoalTick) / (1000 * 60 * 60);
        if (hoursSinceTick >= 72) return true;
      }
      
      return false;
    }

    function showOnboarding() {
      document.getElementById('onboardingOverlay').classList.add('active');
      document.getElementById('onboardingStep1').classList.add('active');
    }

    function hideOnboarding() {
      document.getElementById('onboardingOverlay').classList.remove('active');
    }

    function showGoalCheckin() {
      const overlay = document.getElementById('goalCheckinOverlay');
      const list = document.getElementById('checkinGoalsList');
      list.innerHTML = '';
      
      goals.shortterm.forEach((goal, index) => {
        const item = document.createElement('div');
        item.className = 'checkin-goal-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'checkin-goal-checkbox';
        checkbox.checked = goal.completed;
        checkbox.dataset.index = index;
        checkbox.addEventListener('change', function() {
          goals.shortterm[index].completed = this.checked;
          text.classList.toggle('completed', this.checked);
        });
        
        const text = document.createElement('span');
        text.className = 'checkin-goal-text';
        if (goal.completed) text.classList.add('completed');
        text.textContent = goal.text;
        
        item.appendChild(checkbox);
        item.appendChild(text);
        list.appendChild(item);
      });
      
      overlay.classList.add('active');
    }

    function hideGoalCheckin() {
      document.getElementById('goalCheckinOverlay').classList.remove('active');
    }

    function updateBackgroundGoal() {
      const bgGoal = document.getElementById('chatBackgroundGoal');
      if (!bgGoal) return;
      
      if (!goals.longterm || !settings.showLongTermGoal) {
        bgGoal.style.opacity = '0';
        return;
      }
      
      bgGoal.textContent = '"' + goals.longterm + '"';
      
      // Calculate opacity based on message count (caps at 0.15)
      const messageCount = state.messages.filter(m => m.role === 'user').length;
      const opacity = Math.min(messageCount * 0.03, 0.15);
      bgGoal.style.opacity = opacity.toString();
    }

    // SETTINGS MANAGEMENT
    let settings = {
      frictionMode: 'full', // 'off', 'light', 'full'
      messageDelay: 0, // 0, 5, 15, 30, 45 seconds
      allowCancelDelay: true,
      showShortTermGoal: true,
      showLongTermGoal: true,
      lockUntil: null
    };

    function loadSettings() {
      const saved = localStorage.getItem('friction_settings');
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          settings = Object.assign(settings, parsed);
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    }

    function saveSettings() {
      localStorage.setItem('friction_settings', JSON.stringify(settings));
    }

    function isSettingsLocked() {
      if (!settings.lockUntil) return false;
      return Date.now() < settings.lockUntil;
    }

    function getRemainingLockTime() {
      if (!settings.lockUntil) return 0;
      return Math.max(0, settings.lockUntil - Date.now());
    }

    function formatLockTime(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      return String(hours).padStart(2, '0') + ':' + 
             String(minutes).padStart(2, '0') + ':' + 
             String(seconds).padStart(2, '0');
    }

    function showSettings() {
      loadSettings();
      
      const overlay = document.getElementById('settingsOverlay');
      const content = document.getElementById('settingsContent');
      const lockBanner = document.getElementById('settingsLockBanner');
      
      // Set current values in form
      document.querySelector('input[name="frictionMode"][value="' + settings.frictionMode + '"]').checked = true;
      document.querySelector('input[name="messageDelay"][value="' + settings.messageDelay + '"]').checked = true;
      document.getElementById('allowCancelDelay').checked = settings.allowCancelDelay;
      document.getElementById('showShortTermGoal').checked = settings.showShortTermGoal;
      document.getElementById('showLongTermGoal').checked = settings.showLongTermGoal;
      
      // Update delay section based on friction mode
      updateDelayAvailability();
      
      // Check if locked
      if (isSettingsLocked()) {
        content.classList.add('locked');
        lockBanner.style.display = 'flex';
        updateLockTimer();
      } else {
        content.classList.remove('locked');
        lockBanner.style.display = 'none';
      }
      
      overlay.classList.add('active');
    }

    function updateDelayAvailability() {
      const frictionMode = document.querySelector('input[name="frictionMode"]:checked').value;
      const delayOptions = document.getElementById('delayOptions');
      const delayNote = document.getElementById('delayDisabledNote');
      
      if (frictionMode === 'full' || frictionMode === 'strict') {
        delayOptions.classList.add('disabled');
        delayNote.style.display = 'block';
        // Reset delay to off when using code friction
        settings.messageDelay = 0;
        document.querySelector('input[name="messageDelay"][value="0"]').checked = true;
        saveSettings();
      } else {
        delayOptions.classList.remove('disabled');
        delayNote.style.display = 'none';
      }
    }

    function hideSettings() {
      document.getElementById('settingsOverlay').classList.remove('active');
    }

    let lockTimerInterval = null;

    function updateLockTimer() {
      const remaining = getRemainingLockTime();
      const timeEl = document.getElementById('lockTimeRemaining');
      
      if (remaining <= 0) {
        settings.lockUntil = null;
        saveSettings();
        document.getElementById('settingsContent').classList.remove('locked');
        document.getElementById('settingsLockBanner').style.display = 'none';
        if (lockTimerInterval) {
          clearInterval(lockTimerInterval);
          lockTimerInterval = null;
        }
        return;
      }
      
      timeEl.textContent = formatLockTime(remaining);
      
      if (!lockTimerInterval) {
        lockTimerInterval = setInterval(updateLockTimer, 1000);
      }
    }

    function lockSettings() {
      const days = parseInt(document.getElementById('lockDays').value, 10) || 0;
      const hours = parseInt(document.getElementById('lockHours').value, 10) || 0;
      const minutes = parseInt(document.getElementById('lockMinutes').value, 10) || 0;
      
      const duration = (days * 24 * 60 * 60 * 1000) + (hours * 60 * 60 * 1000) + (minutes * 60 * 1000);
      
      if (duration < 60000) {
        alert('Please set a lock duration of at least 1 minute.');
        return;
      }
      
      settings.lockUntil = Date.now() + duration;
      saveSettings();
      
      document.getElementById('settingsContent').classList.add('locked');
      document.getElementById('settingsLockBanner').style.display = 'flex';
      updateLockTimer();
    }

    // MESSAGE DELAY OVERLAY
    let delayInterval = null;
    let delayMessage = null;

    function showDelayOverlay(message) {
      delayMessage = message;
      const overlay = document.getElementById('delayOverlay');
      const timeEl = document.getElementById('delayTime');
      const progressEl = document.getElementById('delayRingProgress');
      const hintEl = document.getElementById('delayHint');
      const cancelBtn = document.getElementById('delayCancelBtn');
      
      const totalSeconds = settings.messageDelay;
      let remaining = totalSeconds;
      
      // Set hint based on goal
      const activeGoal = getActiveShortTermGoal();
      if (activeGoal) {
        hintEl.textContent = 'While you wait... "' + activeGoal.text + '"';
      } else {
        hintEl.textContent = 'Take a breath. Is this message necessary?';
      }
      
      // Show/hide cancel button
      if (settings.allowCancelDelay) {
        cancelBtn.classList.remove('hidden');
      } else {
        cancelBtn.classList.add('hidden');
      }
      
      // Set initial state
      timeEl.textContent = remaining;
      progressEl.style.strokeDashoffset = '0';
      
      overlay.classList.add('active');
      
      delayInterval = setInterval(() => {
        remaining--;
        timeEl.textContent = remaining;
        
        // Update progress ring (283 is circumference of circle with r=45)
        const progress = ((totalSeconds - remaining) / totalSeconds) * 283;
        progressEl.style.strokeDashoffset = progress;
        
        if (remaining <= 0) {
          clearInterval(delayInterval);
          delayInterval = null;
          hideDelayOverlay();
          sendMessage(delayMessage);
          delayMessage = null;
        }
      }, 1000);
    }

    function hideDelayOverlay() {
      document.getElementById('delayOverlay').classList.remove('active');
      if (delayInterval) {
        clearInterval(delayInterval);
        delayInterval = null;
      }
    }

    function cancelDelay() {
      hideDelayOverlay();
      delayMessage = null;
    }

    // AUTH STATE
    const GOOGLE_CLIENT_ID = '37442638167-t8m3fql61v05h01qmvall1bki9k88tim.apps.googleusercontent.com';
    
    let currentUser = null;
    let isAdmin = false;
    let googleIdToken = null;

    function loadUserFromStorage() {
      const saved = localStorage.getItem('friction_user');
      if (saved) {
        currentUser = JSON.parse(saved);
        isAdmin = currentUser.email === ADMIN_EMAIL;
        googleIdToken = localStorage.getItem('google_id_token');
        return true;
      }
      return false;
    }

    function saveUserToStorage() {
      if (currentUser) {
        localStorage.setItem('friction_user', JSON.stringify(currentUser));
      } else {
        localStorage.removeItem('friction_user');
      }
    }

    function handleGoogleSignIn(response) {
      const base64Url = response.credential.split('.')[1];
      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      const padded = base64 + '==='.slice((base64.length + 3) % 4);
      const payload = JSON.parse(atob(padded));
      
      currentUser = {
        email: payload.email,
        name: payload.name,
        picture: payload.picture
      };
      
      // Save the ID token for API calls
      googleIdToken = response.credential;
      localStorage.setItem('google_id_token', googleIdToken);
      
      isAdmin = currentUser.email === ADMIN_EMAIL;
      saveUserToStorage();
      updateModelAccess();
      updateProfileDisplay();
      showChat();
    }

    function signOut() {
      currentUser = null;
      isAdmin = false;
      googleIdToken = null;
      localStorage.removeItem('friction_user');
      localStorage.removeItem('google_id_token');
      if (typeof google !== 'undefined' && google.accounts) {
        google.accounts.id.disableAutoSelect();
      }
      updateModelAccess();
      showHomepage();
    }

    function updateModelAccess() {
      const options = modelSelect.querySelectorAll('option');
      options.forEach(option => {
        const model = option.value;
        if (PAID_MODELS.includes(model) && !isAdmin) {
          option.disabled = true;
          option.textContent = option.textContent.replace(' üîí', '') + ' üîí';
        } else {
          option.disabled = false;
          option.textContent = option.textContent.replace(' üîí', '');
        }
      });

      // If current selection is a paid model and user is not admin, switch to Gemini
      if (PAID_MODELS.includes(modelSelect.value) && !isAdmin) {
        modelSelect.value = 'gemini';
        state.currentModel = 'gemini';
      }
    }

    function initGoogleSignIn() {
      if (typeof google !== 'undefined' && google.accounts) {
        google.accounts.id.initialize({
          client_id: GOOGLE_CLIENT_ID,
          callback: handleGoogleSignIn,
          auto_select: false
        });

        // Render a hidden Google button that we'll click programmatically
        google.accounts.id.renderButton(
          document.getElementById('googleButtonHidden'),
          { theme: 'outline', size: 'large', width: 280 }
        );

        // Check if user already signed in - auto go to chat
        if (loadUserFromStorage()) {
          updateModelAccess();
          updateProfileDisplay();
          showChat();
        }
        
        // Reveal UI after state is known
        document.body.classList.add('ready');
      } else {
        // Retry if Google script not loaded yet
        setTimeout(initGoogleSignIn, 100);
      }
    }

    // Fallback: reveal UI after timeout in case Google script fails
    setTimeout(() => {
      document.body.classList.add('ready');
    }, 1000);

    initGoogleSignIn();

    // DOM ELEMENTS
    const homepage = document.getElementById('homepage');
    const chatApp = document.getElementById('chatApp');
    const btnApple = document.getElementById('btnApple');
    const btnGoogle = document.getElementById('btnGoogle');
    const btnEmail = document.getElementById('btnEmail');

    const chatMessages = document.getElementById('chatMessages');
    const messageInput = document.getElementById('messageInput');
    const btnSend = document.getElementById('btnSend');
    const modelSelect = document.getElementById('modelSelect');
    const btnMenu = document.getElementById('btnMenu');
    const typingIndicator = document.getElementById('typingIndicator');

    // Side menu elements
    const sideMenu = document.getElementById('sideMenu');
    const menuOverlay = document.getElementById('menuOverlay');
    const btnCloseMenu = document.getElementById('btnCloseMenu');
    const btnNewChat = document.getElementById('btnNewChat');
    const btnSignOut = document.getElementById('btnSignOut');
    const btnSettings = document.getElementById('btnSettings');
    const btnAbout = document.getElementById('btnAbout');
    
    // Profile elements
    const profilePic = document.getElementById('profilePic');
    const profileName = document.getElementById('profileName');
    const profileEmail = document.getElementById('profileEmail');

    // ONBOARDING EVENT LISTENERS
    document.getElementById('onboardingNext1').addEventListener('click', function() {
      document.getElementById('onboardingStep1').classList.remove('active');
      document.getElementById('onboardingStep2').classList.add('active');
    });

    document.getElementById('onboardingBack2').addEventListener('click', function() {
      document.getElementById('onboardingStep2').classList.remove('active');
      document.getElementById('onboardingStep1').classList.add('active');
    });

    document.getElementById('onboardingNext2').addEventListener('click', function() {
      goals.longterm = document.getElementById('inputLongtermGoal').value.trim();
      document.getElementById('onboardingStep2').classList.remove('active');
      document.getElementById('onboardingStep3').classList.add('active');
    });

    document.getElementById('onboardingBack3').addEventListener('click', function() {
      document.getElementById('onboardingStep3').classList.remove('active');
      document.getElementById('onboardingStep2').classList.add('active');
    });

    document.getElementById('addShorttermGoal').addEventListener('click', function() {
      const list = document.getElementById('shorttermGoalsList');
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'shortterm-goal-input';
      input.placeholder = 'Another goal...';
      input.maxLength = 60;
      list.appendChild(input);
      input.focus();
    });

    document.getElementById('onboardingNext3').addEventListener('click', function() {
      const inputs = document.querySelectorAll('#shorttermGoalsList .shortterm-goal-input');
      goals.shortterm = [];
      inputs.forEach(input => {
        const text = input.value.trim();
        if (text) {
          goals.shortterm.push({ text: text, completed: false, createdAt: Date.now() });
        }
      });
      
      // Show summary
      const summary = document.getElementById('onboardingSummary');
      let html = '';
      if (goals.longterm) {
        html += '<div class="onboarding-summary-item">';
        html += '<div class="onboarding-summary-label">Long-term goal</div>';
        html += '<div class="onboarding-summary-text">"' + goals.longterm + '"</div>';
        html += '</div>';
      }
      if (goals.shortterm.length > 0) {
        html += '<div class="onboarding-summary-item">';
        html += '<div class="onboarding-summary-label">Short-term goals</div>';
        goals.shortterm.forEach(g => {
          html += '<div class="onboarding-summary-text">‚Ä¢ ' + g.text + '</div>';
        });
        html += '</div>';
      }
      summary.innerHTML = html || '<p>No goals set - you can add them later from the menu.</p>';
      
      document.getElementById('onboardingStep3').classList.remove('active');
      document.getElementById('onboardingStep4').classList.add('active');
    });

    document.getElementById('onboardingFinish').addEventListener('click', function() {
      goals.onboardingComplete = true;
      goals.lastGoalCheck = Date.now();
      goals.lastGoalTick = Date.now();
      saveGoals();
      hideOnboarding();
      updateBackgroundGoal();
    });

    // Goal check-in listeners
    document.getElementById('checkinSkip').addEventListener('click', function() {
      goals.lastGoalCheck = Date.now();
      saveGoals();
      hideGoalCheckin();
    });

    document.getElementById('checkinSave').addEventListener('click', function() {
      // Remove completed goals and prompt for new ones if all done
      const hasIncomplete = goals.shortterm.some(g => !g.completed);
      
      goals.lastGoalCheck = Date.now();
      goals.lastGoalTick = Date.now();
      saveGoals();
      hideGoalCheckin();
      
      if (!hasIncomplete) {
        // All goals completed - could prompt for new ones
        // For now just clear completed and let them add via menu
        goals.shortterm = goals.shortterm.filter(g => !g.completed);
        saveGoals();
      }
    });

    function updateProfileDisplay() {
      if (currentUser) {
        profilePic.src = currentUser.picture || '';
        profilePic.style.display = currentUser.picture ? 'block' : 'none';
        profileName.textContent = currentUser.name || 'User';
        profileEmail.textContent = currentUser.email || '';
      }
    }

    const frictionOverlay = document.getElementById('frictionOverlay');
    const frictionPairs1 = document.getElementById('frictionPairs1');
    const frictionPairs2 = document.getElementById('frictionPairs2');
    const frictionCancel = document.getElementById('frictionCancel');
    const frictionUnlock = document.getElementById('frictionUnlock');
    const frictionError = document.getElementById('frictionError');

    // SCROLL LOCK
    let _scrollYBeforeLock = 0;

    function lockBodyScroll() {
      if (document.body.classList.contains('scroll-locked')) return;
      _scrollYBeforeLock = window.scrollY || 0;
      document.body.classList.add('scroll-locked');
      document.body.style.top = '-' + _scrollYBeforeLock + 'px';
    }

    function unlockBodyScroll() {
      if (!document.body.classList.contains('scroll-locked')) return;
      document.body.classList.remove('scroll-locked');
      document.body.style.top = '';
      window.scrollTo(0, _scrollYBeforeLock || 0);
    }

    function preventTouchMove(e) {
      const box = document.querySelector('.friction-box');
      if (box && box.contains(e.target)) return;
      e.preventDefault();
    }

    // CODE GENERATION
    function generateChallenge(length) {
      const lower = 'abcdefghjkmnpqrstuvwxyz';
      const upper = 'ABCDEFGHJKMNPQRSTUVWXYZ';
      const numbers = '23456789';
      const symbols = '!@#$%&*^~+-=<>?';

      let result = '';
      for (let i = 0; i < length; i++) {
        const pattern = i % 4;
        let charSet;
        if (pattern === 0) charSet = lower;
        else if (pattern === 1) charSet = symbols;
        else if (pattern === 2) charSet = upper;
        else charSet = numbers;
        result += charSet.charAt(Math.floor(Math.random() * charSet.length));
      }
      return result;
    }

    // NAVIGATION
    function restoreChatUI() {
      if (state.messages.length > 0) {
        // Remove welcome message
        const welcome = chatMessages.querySelector('.welcome-message');
        if (welcome) welcome.remove();
        
        // Clear existing messages (except typing indicator)
        const existingMessages = chatMessages.querySelectorAll('.message');
        existingMessages.forEach(msg => msg.remove());
        
        // Render all saved messages
        state.messages.forEach(msg => {
          const type = msg.role === 'assistant' ? 'ai' : 'user';
          addMessage(msg.content, type);
        });
      }
      
      // Restore model selection
      if (state.currentModel && modelSelect) {
        modelSelect.value = state.currentModel;
      }
    }

    function showChat() {
      // Load saved chat before showing
      loadChatState();
      loadGoals();
      loadSettings();
      
      // Check if session has expired (2 hours = same as friction reset)
      const SESSION_TIMEOUT = 2 * 60 * 60 * 1000; // 2 hours
      const lastActivity = localStorage.getItem('friction_last_activity');
      
      if (lastActivity) {
        const elapsed = Date.now() - parseInt(lastActivity, 10);
        if (elapsed > SESSION_TIMEOUT && state.messages.length > 0) {
          // Save current chat to history before clearing
          saveCurrentChatToHistory();
          // Start fresh
          state.messages = [];
          state.currentChatId = generateChatId();
          localStorage.removeItem('friction_chat');
        }
      }
      
      // Update last activity
      localStorage.setItem('friction_last_activity', Date.now().toString());
      
      homepage.classList.add('hidden');
      chatApp.classList.add('active');
      
      // Restore chat messages (or show welcome if empty)
      if (state.messages.length > 0) {
        restoreChatUI();
      }
      
      // Check if onboarding needed
      if (shouldShowOnboarding()) {
        showOnboarding();
      } else if (shouldShowGoalCheckin()) {
        showGoalCheckin();
      }
      
      // Update background goal
      updateBackgroundGoal();
      
      if (lastMessageTime && frictionLevel > 0) startHeaderTimer();
      updateKeyboardOffset();
      scrollChatToBottom();
    }

    function showHomepage() {
      chatApp.classList.remove('active');
      homepage.classList.remove('hidden');
      clearChatState();
      chatMessages.innerHTML = '<div class="chat-background-goal" id="chatBackgroundGoal"></div><div class="welcome-message"><div class="welcome-icon">‚ú¶</div><h2>How can I help you today?</h2><p>Remember: slow is intentional.</p></div>';
      document.documentElement.style.setProperty('--kb', '0px');
    }

    btnApple.addEventListener('click', function() {
      // TODO: Apple Sign-In
      alert('Apple Sign-In coming soon!');
    });
    
    btnGoogle.addEventListener('click', function() {
      if (!window.google || !google.accounts || !google.accounts.id) {
        initGoogleSignIn();
        return;
      }
      // Click the hidden Google button to trigger sign-in
      const hiddenBtn = document.querySelector('#googleButtonHidden div[role="button"]');
      if (hiddenBtn) {
        hiddenBtn.click();
      } else {
        // Fallback: try One Tap
        google.accounts.id.prompt();
      }
    });
    
    btnEmail.addEventListener('click', function() {
      // TODO: Email Sign-In
      alert('Email Sign-In coming soon!');
    });
    
    // SIDE MENU FUNCTIONS
    function openMenu() {
      renderChatHistoryList();
      sideMenu.classList.add('active');
      menuOverlay.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeMenu() {
      sideMenu.classList.remove('active');
      menuOverlay.classList.remove('active');
      document.body.style.overflow = '';
    }

    btnMenu.addEventListener('click', openMenu);
    btnCloseMenu.addEventListener('click', closeMenu);
    menuOverlay.addEventListener('click', closeMenu);

    btnNewChat.addEventListener('click', function() {
      // Save current chat first if it has messages
      if (state.messages.length > 0) {
        saveCurrentChatToHistory();
      }
      
      // Clear current chat and start fresh
      clearChatState();
      state.currentChatId = generateChatId();
      chatMessages.innerHTML = '<div class="welcome-message"><div class="welcome-icon">‚ú¶</div><h2>How can I help you today?</h2><p>Remember: slow is intentional.</p></div>';
      closeMenu();
    });

    btnSignOut.addEventListener('click', function() {
      closeMenu();
      signOut();
    });

    btnSettings.addEventListener('click', function() {
      closeMenu();
      showSettings();
    });

    btnAbout.addEventListener('click', function() {
      // TODO: Show about page
      closeMenu();
    });

    // Settings event listeners
    document.getElementById('settingsClose').addEventListener('click', hideSettings);

    document.querySelectorAll('input[name="frictionMode"]').forEach(radio => {
      radio.addEventListener('change', function() {
        if (isSettingsLocked()) return;
        settings.frictionMode = this.value;
        saveSettings();
        updateDelayAvailability();
      });
    });

    document.querySelectorAll('input[name="messageDelay"]').forEach(radio => {
      radio.addEventListener('change', function() {
        if (isSettingsLocked()) return;
        settings.messageDelay = parseInt(this.value, 10);
        saveSettings();
      });
    });

    document.getElementById('allowCancelDelay').addEventListener('change', function() {
      if (isSettingsLocked()) return;
      settings.allowCancelDelay = this.checked;
      saveSettings();
    });

    document.getElementById('showShortTermGoal').addEventListener('change', function() {
      if (isSettingsLocked()) return;
      settings.showShortTermGoal = this.checked;
      saveSettings();
    });

    document.getElementById('showLongTermGoal').addEventListener('change', function() {
      if (isSettingsLocked()) return;
      settings.showLongTermGoal = this.checked;
      saveSettings();
      updateBackgroundGoal();
    });

    document.getElementById('btnLockSettings').addEventListener('click', function() {
      if (isSettingsLocked()) return;
      if (confirm('Are you sure? Once locked, you cannot change settings until the timer expires.')) {
        lockSettings();
      }
    });

    // Delay cancel button
    document.getElementById('delayCancelBtn').addEventListener('click', cancelDelay);

    // Lock preset buttons
    document.querySelectorAll('.lock-preset-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const hours = this.dataset.hours;
        const days = this.dataset.days;
        
        document.getElementById('lockDays').value = days || 0;
        document.getElementById('lockHours').value = hours || 0;
        document.getElementById('lockMinutes').value = 0;
      });
    });

    // CHAT HISTORY MANAGEMENT
    function generateChatId() {
      return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    function getChatTitle(messages) {
      if (!messages || messages.length === 0) return 'New Chat';
      const firstUserMsg = messages.find(m => m.role === 'user');
      if (firstUserMsg) {
        const title = firstUserMsg.content.substring(0, 40);
        return title.length < firstUserMsg.content.length ? title + '...' : title;
      }
      return 'New Chat';
    }

    function loadChatHistory() {
      const saved = localStorage.getItem('friction_history');
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch (e) {
          return [];
        }
      }
      return [];
    }

    function saveChatHistory(history) {
      localStorage.setItem('friction_history', JSON.stringify(history));
    }

    function saveCurrentChatToHistory() {
      if (state.messages.length === 0) return;
      
      let history = loadChatHistory();
      const chatData = {
        id: state.currentChatId || generateChatId(),
        messages: state.messages,
        model: state.currentModel,
        updatedAt: Date.now()
      };
      
      // Update existing or add new
      const existingIndex = history.findIndex(c => c.id === chatData.id);
      if (existingIndex >= 0) {
        history[existingIndex] = chatData;
      } else {
        history.unshift(chatData);
      }
      
      // Keep only last 50 chats
      history = history.slice(0, 50);
      
      saveChatHistory(history);
      state.currentChatId = chatData.id;
    }

    function loadChatFromHistory(chatId) {
      const history = loadChatHistory();
      const chat = history.find(c => c.id === chatId);
      if (chat) {
        state.messages = chat.messages;
        state.currentModel = chat.model;
        state.currentChatId = chat.id;
        modelSelect.value = chat.model;
        saveChatState();
        restoreChatUI();
        closeMenu();
      }
    }

    function deleteChatFromHistory(chatId) {
      let history = loadChatHistory();
      history = history.filter(c => c.id !== chatId);
      saveChatHistory(history);
      renderChatHistoryList();
    }

    function renderChatHistoryList() {
      const container = document.getElementById('chatHistoryList');
      const history = loadChatHistory();
      
      if (history.length === 0) {
        container.innerHTML = '<div class="menu-empty">No chats yet</div>';
        return;
      }
      
      container.innerHTML = '';
      history.forEach(chat => {
        const item = document.createElement('div');
        item.className = 'menu-history-item';
        if (chat.id === state.currentChatId) {
          item.classList.add('active');
        }
        
        const title = document.createElement('button');
        title.className = 'menu-history-title';
        title.textContent = getChatTitle(chat.messages);
        title.addEventListener('click', function() {
          loadChatFromHistory(chat.id);
        });
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'menu-history-delete';
        deleteBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
        deleteBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          deleteChatFromHistory(chat.id);
        });
        
        item.appendChild(title);
        item.appendChild(deleteBtn);
        container.appendChild(item);
      });
    }

    // FRICTION SYSTEM
    let challenge1 = '';
    let challenge2 = '';
    let frictionLevel = 0;
    let lastMessageTime = null;
    let timerInterval = null;
    const RESET_TIME = 2 * 60 * 60 * 1000;

    function loadFrictionState() {
      const saved = localStorage.getItem('friction_state');
      if (saved) {
        const s = JSON.parse(saved);
        lastMessageTime = s.lastMessageTime;
        frictionLevel = s.frictionLevel || 0;
        if (lastMessageTime && (Date.now() - lastMessageTime > RESET_TIME)) {
          frictionLevel = 0;
          lastMessageTime = null;
          saveFrictionState();
        }
      }
    }

    function saveFrictionState() {
      localStorage.setItem('friction_state', JSON.stringify({ frictionLevel, lastMessageTime }));
    }

    function formatTimeRemaining(ms) {
      if (ms <= 0) return '0:00:00';
      const hours = Math.floor(ms / (1000 * 60 * 60));
      const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((ms % (1000 * 60)) / 1000);
      return hours + ':' + minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
    }

    function updateTimer() {
      const timerEl = document.getElementById('frictionTimer');
      const headerTimerEl = document.getElementById('headerTimer');

      if (!lastMessageTime || frictionLevel === 0) {
        timerEl.textContent = '';
        headerTimerEl.classList.remove('active');
        headerTimerEl.textContent = '';
        return;
      }

      const elapsed = Date.now() - lastMessageTime;
      const remaining = RESET_TIME - elapsed;

      if (remaining <= 0) {
        frictionLevel = 0;
        lastMessageTime = null;
        saveFrictionState();
        timerEl.textContent = 'üéâ Reset! Back to Level 1.';
        headerTimerEl.textContent = 'üéâ Level 1';
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
        setTimeout(() => { headerTimerEl.classList.remove('active'); }, 5000);
      } else {
        const timeStr = formatTimeRemaining(remaining);
        timerEl.textContent = '‚è± Resets in ' + timeStr;
        const maxLevel = settings.frictionMode === 'strict' ? 15 : 7;
        headerTimerEl.textContent = 'L' + Math.min(frictionLevel + 1, maxLevel) + ' ¬∑ ' + timeStr;
        headerTimerEl.classList.add('active');
      }
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      updateTimer();
      timerInterval = setInterval(updateTimer, 1000);
    }

    let headerTimerInterval = null;
    function startHeaderTimer() {
      if (headerTimerInterval) clearInterval(headerTimerInterval);
      updateTimer();
      headerTimerInterval = setInterval(updateTimer, 1000);
    }

    function getFrictionConfig() {
      // Strict mode - original hardcore 15 levels
      if (settings.frictionMode === 'strict') {
        const strictConfigs = [
          { rows: 1, length: 6 },   // Level 1
          { rows: 1, length: 8 },   // Level 2
          { rows: 1, length: 10 },  // Level 3
          { rows: 1, length: 12 },  // Level 4
          { rows: 1, length: 14 },  // Level 5
          { rows: 1, length: 16 },  // Level 6
          { rows: 1, length: 18 },  // Level 7
          { rows: 1, length: 20 },  // Level 8
          { rows: 2, length: 12 },  // Level 9
          { rows: 2, length: 14 },  // Level 10
          { rows: 2, length: 16 },  // Level 11
          { rows: 2, length: 18 },  // Level 12
          { rows: 2, length: 20 },  // Level 13
          { rows: 2, length: 20 },  // Level 14
          { rows: 2, length: 20 },  // Level 15
        ];
        return strictConfigs[Math.min(frictionLevel, 14)];
      }
      
      // Full mode - gentle 7 levels, max 10 chars
      const configs = [
        { rows: 1, length: 4 },   // Level 1
        { rows: 1, length: 5 },   // Level 2
        { rows: 1, length: 6 },   // Level 3
        { rows: 1, length: 7 },   // Level 4
        { rows: 1, length: 8 },   // Level 5
        { rows: 1, length: 9 },   // Level 6
        { rows: 1, length: 10 },  // Level 7+
      ];
      return configs[Math.min(frictionLevel, 6)];
    }

    function handlePaste(e) {
      e.preventDefault();
      frictionError.textContent = 'No pasting ‚Äî type it out!';
    }

    function createCharPairs(code, container) {
      container.innerHTML = '';
      
      for (let i = 0; i < code.length; i++) {
        // Create pair container (code on top, input below)
        const pair = document.createElement('div');
        pair.className = 'friction-pair';
        
        // Create display character block
        const charBlock = document.createElement('div');
        charBlock.className = 'friction-char';
        charBlock.textContent = code[i];
        pair.appendChild(charBlock);
        
        // Create input block
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'friction-char-input';
        input.maxLength = 1;
        input.autocomplete = 'off';
        input.autocorrect = 'off';
        input.autocapitalize = 'off';
        input.spellcheck = false;
        input.dataset.index = i;
        input.dataset.expected = code[i];
        
        input.addEventListener('input', handleCharInput);
        input.addEventListener('keydown', handleCharKeydown);
        input.addEventListener('paste', handlePaste);
        input.addEventListener('drop', e => e.preventDefault());
        
        pair.appendChild(input);
        container.appendChild(pair);
      }
    }

    function handleCharInput(e) {
      const input = e.target;
      const value = input.value;
      const expected = input.dataset.expected;
      
      if (value) {
        if (value === expected) {
          input.classList.add('success');
          input.classList.remove('error');
          // Move to next input
          const pair = input.closest('.friction-pair');
          const nextPair = pair.nextElementSibling;
          if (nextPair) {
            const nextInput = nextPair.querySelector('.friction-char-input');
            if (nextInput) nextInput.focus();
          }
        } else {
          input.classList.add('error');
          input.classList.remove('success');
        }
      } else {
        input.classList.remove('success', 'error');
      }
      
      checkAllInputs();
    }

    function handleCharKeydown(e) {
      const input = e.target;
      const pair = input.closest('.friction-pair');
      
      if (e.key === 'Backspace' && !input.value) {
        const prevPair = pair.previousElementSibling;
        if (prevPair) {
          const prevInput = prevPair.querySelector('.friction-char-input');
          if (prevInput) {
            prevInput.focus();
            prevInput.select();
          }
        }
      } else if (e.key === 'ArrowLeft') {
        const prevPair = pair.previousElementSibling;
        if (prevPair) {
          const prevInput = prevPair.querySelector('.friction-char-input');
          if (prevInput) prevInput.focus();
        }
      } else if (e.key === 'ArrowRight') {
        const nextPair = pair.nextElementSibling;
        if (nextPair) {
          const nextInput = nextPair.querySelector('.friction-char-input');
          if (nextInput) nextInput.focus();
        }
      }
    }

    function checkAllInputs() {
      const config = getFrictionConfig();
      
      // Check row 1
      const inputs1 = frictionPairs1.querySelectorAll('.friction-char-input');
      let match1 = true;
      inputs1.forEach(input => {
        if (input.value !== input.dataset.expected) match1 = false;
      });
      
      // Check row 2 if needed
      let match2 = true;
      if (config.rows === 2) {
        const inputs2 = frictionPairs2.querySelectorAll('.friction-char-input');
        inputs2.forEach(input => {
          if (input.value !== input.dataset.expected) match2 = false;
        });
      }
      
      if (match1 && match2) {
        frictionUnlock.disabled = false;
        frictionUnlock.classList.add('ready');
      } else {
        frictionUnlock.disabled = true;
        frictionUnlock.classList.remove('ready');
      }
      
      frictionError.textContent = '';
    }

    function showFriction(message) {
      if (lastMessageTime && (Date.now() - lastMessageTime > RESET_TIME)) {
        frictionLevel = 0;
        lastMessageTime = null;
        saveFrictionState();
      }

      state.pendingMessage = message;
      const config = getFrictionConfig();

      // Show short-term goal reminder
      const goalReminder = document.getElementById('frictionGoalReminder');
      const activeGoal = getActiveShortTermGoal();
      if (activeGoal && settings.showShortTermGoal) {
        goalReminder.innerHTML = '<div class="friction-goal-label">Your focus</div><div class="friction-goal-text">"' + activeGoal.text + '"</div>';
      } else {
        goalReminder.innerHTML = '';
      }

      // Show code input row
      document.getElementById('frictionRow1').style.display = 'block';
      
      challenge1 = generateChallenge(config.length);
      createCharPairs(challenge1, frictionPairs1);

      const row2 = document.getElementById('frictionRow2');
      if (config.rows === 2) {
        challenge2 = generateChallenge(config.length);
        createCharPairs(challenge2, frictionPairs2);
        row2.style.display = 'block';
      } else {
        challenge2 = '';
        row2.style.display = 'none';
      }

      frictionUnlock.disabled = true;
      frictionUnlock.classList.remove('ready');
      frictionError.textContent = '';

      const subtitle = document.querySelector('.friction-subtitle');
      if (settings.frictionMode === 'strict') {
        // Strict mode - 15 levels
        if (frictionLevel < 14) {
          subtitle.textContent = '‚ò†Ô∏è STRICT Level ' + (frictionLevel + 1) + ' of 15 ‚Äî No mercy.';
        } else {
          subtitle.textContent = '‚ò†Ô∏è STRICT Level 15 ‚Äî Maximum punishment. 2hr reset.';
        }
      } else {
        // Full mode - 7 levels
        if (frictionLevel < 6) {
          subtitle.textContent = 'Level ' + (frictionLevel + 1) + ' of 7 ‚Äî Type the code to send.';
        } else {
          subtitle.textContent = 'Level 7 of 7 ‚Äî Maximum friction. Take a 2-hour break to reset.';
        }
      }

      startTimer();
      frictionOverlay.classList.add('active');
      lockBodyScroll();
      document.addEventListener('touchmove', preventTouchMove, { passive: false });
      document.documentElement.style.setProperty('--kb', '0px');
      
      // Focus first input
      setTimeout(() => {
        const firstInput = frictionPairs1.querySelector('.friction-char-input');
        if (firstInput) firstInput.focus();
      }, 10);
    }

    function hideFriction() {
      frictionOverlay.classList.remove('active');
      state.pendingMessage = null;
      if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
      document.removeEventListener('touchmove', preventTouchMove);
      unlockBodyScroll();
      startHeaderTimer();
      setTimeout(updateKeyboardOffset, 80);
      setTimeout(scrollChatToBottom, 100);
    }

    frictionCancel.addEventListener('click', hideFriction);

    frictionUnlock.addEventListener('click', function() {
      // Only increase level for full or strict friction modes
      if (settings.frictionMode === 'full' || settings.frictionMode === 'strict') {
        const maxLevel = settings.frictionMode === 'strict' ? 14 : 6;
        if (frictionLevel < maxLevel) frictionLevel++;
        lastMessageTime = Date.now();
        saveFrictionState();
      }

      const timerEl = document.getElementById('frictionTimer');

      if (document.activeElement && typeof document.activeElement.blur === 'function') {
        document.activeElement.blur();
      }

      // Save the message BEFORE hiding (hideFriction clears pendingMessage)
      const messageToSend = state.pendingMessage;
      
      hideFriction();
      
      // Check if message delay is enabled
      if (settings.messageDelay > 0) {
        showDelayOverlay(messageToSend);
      } else {
        sendMessage(messageToSend);
      }
    });

    function showLightFriction(message) {
      state.pendingMessage = message;
      
      // Show a simplified overlay with just the goal
      const goalReminder = document.getElementById('frictionGoalReminder');
      const activeGoal = getActiveShortTermGoal();
      if (activeGoal && settings.showShortTermGoal) {
        goalReminder.innerHTML = '<div class="friction-goal-label">Your focus</div><div class="friction-goal-text">"' + activeGoal.text + '"</div>';
      } else {
        goalReminder.innerHTML = '<div class="friction-goal-label">Pause & reflect</div><div class="friction-goal-text">Do you really need this right now?</div>';
      }
      
      // Hide code input rows
      document.getElementById('frictionRow1').style.display = 'none';
      document.getElementById('frictionRow2').style.display = 'none';
      
      // Update subtitle
      document.querySelector('.friction-subtitle').textContent = 'Take a moment before sending.';
      
      // Enable send button immediately
      frictionUnlock.disabled = false;
      frictionUnlock.classList.add('ready');
      frictionError.textContent = '';
      
      frictionOverlay.classList.add('active');
      lockBodyScroll();
    }

    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission().catch(() => {});
    }

    loadFrictionState();

    // CHAT FUNCTIONS
    function formatMessageContent(content) {
      // Convert URLs to clickable links
      const urlRegex = /(https?:\/\/[^\s\]]+)/g;
      let escaped = content
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // Replace URLs with anchor tags
      let withLinks = escaped.replace(urlRegex, url => {
        // Clean up any trailing punctuation that got caught
        const cleanUrl = url.replace(/[.,;:!?)]+$/, '');
        const trailing = url.substring(cleanUrl.length);
        return '<a href="' + cleanUrl + '" target="_blank" rel="noopener noreferrer">' + cleanUrl + '</a>' + trailing;
      });
      
      // Convert **text** to bold
      withLinks = withLinks.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      
      // Convert line breaks
      withLinks = withLinks.replace(/\n/g, '<br>');
      
      return withLinks;
    }

    function addMessage(content, type) {
      const div = document.createElement('div');
      div.className = 'message message-' + type;
      
      if (type === 'ai') {
        div.innerHTML = formatMessageContent(content);
      } else {
        div.textContent = content;
      }
      
      chatMessages.appendChild(div);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    async function sendMessage(content) {
      // Prevent duplicate sends
      if (state.isProcessing) return;
      
      const model = modelSelect.value;
      state.currentModel = model;
      
      const welcome = chatMessages.querySelector('.welcome-message');
      if (welcome) welcome.remove();

      addMessage(content, 'user');
      state.messages.push({ role: 'user', content: content });
      saveChatState();
      
      // Update background goal opacity
      updateBackgroundGoal();

      state.isProcessing = true;
      btnSend.disabled = true;

      typingIndicator.classList.add('active');
      chatMessages.appendChild(typingIndicator);
      chatMessages.scrollTop = chatMessages.scrollHeight;

      try {
        const response = await callBackend(model, state.messages);
        state.messages.push({ role: 'assistant', content: response });
        saveChatState();
        addMessage(response, 'ai');
      } catch (error) {
        addMessage('Error: ' + error.message, 'error');
      } finally {
        state.isProcessing = false;
        btnSend.disabled = false;
        typingIndicator.classList.remove('active');
        requestAnimationFrame(scrollChatToBottom);
      }
    }

    async function callBackend(model, messages) {
      // Get Google ID token from localStorage
      const idToken = localStorage.getItem('google_id_token');
      if (!idToken) {
        throw new Error('Not authenticated. Please sign in again.');
      }

      const res = await fetch('/api/chat', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${idToken}`
        },
        body: JSON.stringify({ 
          model: model, 
          messages: messages 
        })
      });

      if (!res.ok) {
        let errorMsg = 'Backend API error';
        try { 
          const error = await res.json(); 
          errorMsg = error.error || errorMsg; 
        } catch (e) {}
        throw new Error(errorMsg);
      }

      const data = await res.json();
      return data.response;
    }

    // INPUT HANDLING
    messageInput.addEventListener('input', function() {
      messageInput.style.height = 'auto';
      messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
      requestAnimationFrame(scrollChatToBottom);
    });

    function handleSend() {
      const content = messageInput.value.trim();
      if (!content || state.isProcessing) return;
      messageInput.value = '';
      messageInput.style.height = 'auto';
      
      // Check if user is authenticated
      if (!currentUser) {
        alert('Please sign in first.');
        return;
      }
      
      // Check friction mode
      if (settings.frictionMode === 'off') {
        // No friction - send directly (but check delay)
        if (settings.messageDelay > 0) {
          showDelayOverlay(content);
        } else {
          sendMessage(content);
        }
      } else if (settings.frictionMode === 'light') {
        // Light mode - show goal only, no typing
        showLightFriction(content);
      } else {
        // Full or Strict mode - show goal + typing code
        showFriction(content);
      }
    }

    btnSend.addEventListener('click', handleSend);

    messageInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    });

    // iOS KEYBOARD
    function scrollChatToBottom() {
      if (!chatApp.classList.contains('active')) return;
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function updateKeyboardOffset() {
      if (!window.visualViewport) return;
      const vv = window.visualViewport;
      const keyboardHeight = Math.max(0, window.innerHeight - vv.height - vv.offsetTop);
      const overlayOpen = frictionOverlay.classList.contains('active');
      document.documentElement.style.setProperty('--kb', overlayOpen ? '0px' : (keyboardHeight + 'px'));

      if (!overlayOpen && keyboardHeight > 0 && document.activeElement === messageInput) {
        requestAnimationFrame(() => {
          scrollChatToBottom();
          messageInput.scrollIntoView({ block: 'end', behavior: 'auto' });
        });
      }
    }

    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', updateKeyboardOffset);
      window.visualViewport.addEventListener('scroll', updateKeyboardOffset);
    }

    document.addEventListener('focusin', function(e) {
      if (e.target === messageInput) {
        setTimeout(updateKeyboardOffset, 50);
        setTimeout(scrollChatToBottom, 80);
      }
    });

    document.addEventListener('focusout', function(e) {
      if (e.target === messageInput) {
        setTimeout(() => {
          document.documentElement.style.setProperty('--kb', '0px');
          scrollChatToBottom();
        }, 80);
      }
    });

    updateKeyboardOffset();
  </script>

</body>
</html>