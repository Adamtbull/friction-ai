<script>
  // STATE
  let state = {
    messages: [],
    pendingMessage: null,
    isProcessing: false
  };

  // AUTH STATE
  const GOOGLE_CLIENT_ID = '37442638167-t8m3fql61v05h01qmvall1bki9k88tim.apps.googleusercontent.com';
  const ADMIN_EMAIL = 'fatboydimsim@gmail.com';
  
  let currentUser = null;
  let isAdmin = false;

  // Free models available to everyone, paid models only for admin
  const FREE_MODELS = ['gemini', 'bing'];
  const PAID_MODELS = ['claude', 'gpt', 'grok', 'perplexity'];

  function loadUserFromStorage() {
    const saved = localStorage.getItem('friction_user');
    if (saved) {
      currentUser = JSON.parse(saved);
      isAdmin = currentUser.email === ADMIN_EMAIL;
      return true;
    }
    return false;
  }

  function saveUserToStorage() {
    if (currentUser) {
      localStorage.setItem('friction_user', JSON.stringify(currentUser));
    } else {
      localStorage.removeItem('friction_user');
    }
  }

  function handleGoogleSignIn(response) {
    // Decode the JWT token
    const payload = JSON.parse(atob(response.credential.split('.')[1]));
    
    currentUser = {
      email: payload.email,
      name: payload.name,
      picture: payload.picture
    };
    
    isAdmin = currentUser.email === ADMIN_EMAIL;
    saveUserToStorage();
    updateModelAccess();
    updateProfileDisplay();
    showChat();
  }

  function signOut() {
    currentUser = null;
    isAdmin = false;
    localStorage.removeItem('friction_user');
    google.accounts.id.disableAutoSelect();
    updateModelAccess();
    showHomepage();
  }

  function updateModelAccess() {
    const options = modelSelect.querySelectorAll('option');
    options.forEach(function(option) {
      const model = option.value;
      if (PAID_MODELS.includes(model) && !isAdmin) {
        option.disabled = true;
        option.textContent = option.textContent.replace(' ðŸ”’', '') + ' ðŸ”’';
      } else {
        option.disabled = false;
        option.textContent = option.textContent.replace(' ðŸ”’', '');
      }
    });

    // If current selection is a paid model and user is not admin, switch to Gemini
    if (PAID_MODELS.includes(modelSelect.value) && !isAdmin) {
      modelSelect.value = 'gemini';
    }
  }

  function initGoogleSignIn() {
    if (typeof google !== 'undefined' && google.accounts) {
      google.accounts.id.initialize({
        client_id: GOOGLE_CLIENT_ID,
        callback: handleGoogleSignIn,
        auto_select: false
      });

      // Render a hidden Google button that we'll click programmatically
      google.accounts.id.renderButton(
        document.getElementById('googleButtonHidden'),
        { theme: 'outline', size: 'large', width: 280 }
      );

      // Check if user already signed in - auto go to chat
      if (loadUserFromStorage()) {
        updateModelAccess();
        updateProfileDisplay();
        showChat(); // Auto-navigate to chat if already signed in
      }
    } else {
      // Retry if Google script not loaded yet
      setTimeout(initGoogleSignIn, 100);
    }
  }

  initGoogleSignIn();

  // DOM ELEMENTS
  const homepage = document.getElementById('homepage');
  const chatApp = document.getElementById('chatApp');
  const btnApple = document.getElementById('btnApple');
  const btnGoogle = document.getElementById('btnGoogle');
  const btnEmail = document.getElementById('btnEmail');

  const chatMessages = document.getElementById('chatMessages');
  const messageInput = document.getElementById('messageInput');
  const btnSend = document.getElementById('btnSend');
  const modelSelect = document.getElementById('modelSelect');
  const btnMenu = document.getElementById('btnMenu');
  const typingIndicator = document.getElementById('typingIndicator');

  // Side menu elements
  const sideMenu = document.getElementById('sideMenu');
  const menuOverlay = document.getElementById('menuOverlay');
  const btnCloseMenu = document.getElementById('btnCloseMenu');
  const btnNewChat = document.getElementById('btnNewChat');
  const btnSignOut = document.getElementById('btnSignOut');
  const btnSettings = document.getElementById('btnSettings');
  const btnAbout = document.getElementById('btnAbout');
  
  // Profile elements
  const profilePic = document.getElementById('profilePic');
  const profileName = document.getElementById('profileName');
  const profileEmail = document.getElementById('profileEmail');

  function updateProfileDisplay() {
    if (currentUser) {
      profilePic.src = currentUser.picture || '';
      profilePic.style.display = currentUser.picture ? 'block' : 'none';
      profileName.textContent = currentUser.name || 'User';
      profileEmail.textContent = currentUser.email || '';
    }
  }

  const frictionOverlay = document.getElementById('frictionOverlay');
  const frictionCode1 = document.getElementById('frictionCode1');
  const frictionCode2 = document.getElementById('frictionCode2');
  const frictionInput1 = document.getElementById('frictionInput1');
  const frictionInput2 = document.getElementById('frictionInput2');
  const frictionCancel = document.getElementById('frictionCancel');
  const frictionUnlock = document.getElementById('frictionUnlock');
  const frictionError = document.getElementById('frictionError');

  // SCROLL LOCK
  let _scrollYBeforeLock = 0;

  function lockBodyScroll() {
    if (document.body.classList.contains('scroll-locked')) return;
    _scrollYBeforeLock = window.scrollY || 0;
    document.body.classList.add('scroll-locked');
    document.body.style.top = '-' + _scrollYBeforeLock + 'px';
  }

  function unlockBodyScroll() {
    if (!document.body.classList.contains('scroll-locked')) return;
    document.body.classList.remove('scroll-locked');
    document.body.style.top = '';
    window.scrollTo(0, _scrollYBeforeLock || 0);
  }

  function preventTouchMove(e) {
    const box = document.querySelector('.friction-box');
    if (box && box.contains(e.target)) return;
    e.preventDefault();
  }

  // CODE GENERATION
  function generateChallenge(length) {
    const lower = 'abcdefghjkmnpqrstuvwxyz';
    const upper = 'ABCDEFGHJKMNPQRSTUVWXYZ';
    const numbers = '23456789';
    const symbols = '!@#$%&*^~+-=<>?';

    let result = '';
    for (let i = 0; i < length; i++) {
      const pattern = i % 4;
      let charSet;
      if (pattern === 0) charSet = lower;
      else if (pattern === 1) charSet = symbols;
      else if (pattern === 2) charSet = upper;
      else charSet = numbers;
      result += charSet.charAt(Math.floor(Math.random() * charSet.length));
    }
    return result;
  }

  // NAVIGATION
  function showChat() {
    homepage.classList.add('hidden');
    chatApp.classList.add('active');
    if (lastMessageTime && frictionLevel > 0) startHeaderTimer();
    updateKeyboardOffset();
    scrollChatToBottom();
  }

  function showHomepage() {
    chatApp.classList.remove('active');
    homepage.classList.remove('hidden');
    state.messages = [];
    chatMessages.innerHTML = '<div class="welcome-message"><div class="welcome-icon">âœ¦</div><h2>How can I help you today?</h2><p>Remember: slow is intentional.</p></div>';
    document.documentElement.style.setProperty('--kb', '0px');
  }

  btnApple.addEventListener('click', function() {
    // TODO: Apple Sign-In
    alert('Apple Sign-In coming soon!');
  });
  
  btnGoogle.addEventListener('click', function() {
    // Click the hidden Google button to trigger sign-in
    const hiddenBtn = document.querySelector('#googleButtonHidden div[role="button"]');
    if (hiddenBtn) {
      hiddenBtn.click();
    } else {
      // Fallback: try One Tap
      google.accounts.id.prompt();
    }
  });
  
  btnEmail.addEventListener('click', function() {
    // TODO: Email Sign-In
    alert('Email Sign-In coming soon!');
  });
  
  // SIDE MENU FUNCTIONS
  function openMenu() {
    sideMenu.classList.add('active');
    menuOverlay.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeMenu() {
    sideMenu.classList.remove('active');
    menuOverlay.classList.remove('active');
    document.body.style.overflow = '';
  }

  btnMenu.addEventListener('click', openMenu);
  btnCloseMenu.addEventListener('click', closeMenu);
  menuOverlay.addEventListener('click', closeMenu);

  btnNewChat.addEventListener('click', function() {
    // Clear current chat and start fresh
    state.messages = [];
    chatMessages.innerHTML = '<div class="welcome-message"><div class="welcome-icon">âœ¦</div><h2>How can I help you today?</h2><p>Remember: slow is intentional.</p></div>';
    closeMenu();
  });

  btnSignOut.addEventListener('click', function() {
    closeMenu();
    signOut();
  });

  btnSettings.addEventListener('click', function() {
    // TODO: Open settings
    closeMenu();
  });

  btnAbout.addEventListener('click', function() {
    // TODO: Show about page
    closeMenu();
  });

  // Category expand/collapse
  document.querySelectorAll('.menu-category-header').forEach(function(header) {
    header.addEventListener('click', function() {
      const category = this.closest('.menu-category');
      category.classList.toggle('expanded');
    });
  });

  // FRICTION SYSTEM
  let challenge1 = '';
  let challenge2 = '';
  let frictionLevel = 0;
  let lastMessageTime = null;
  let timerInterval = null;
  const RESET_TIME = 2 * 60 * 60 * 1000;

  function loadFrictionState() {
    const saved = localStorage.getItem('friction_state');
    if (saved) {
      const s = JSON.parse(saved);
      lastMessageTime = s.lastMessageTime;
      frictionLevel = s.frictionLevel || 0;
      if (lastMessageTime && (Date.now() - lastMessageTime > RESET_TIME)) {
        frictionLevel = 0;
        lastMessageTime = null;
        saveFrictionState();
      }
    }
  }

  function saveFrictionState() {
    localStorage.setItem('friction_state', JSON.stringify({ frictionLevel, lastMessageTime }));
  }

  function formatTimeRemaining(ms) {
    if (ms <= 0) return '0:00:00';
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    return hours + ':' + minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
  }

  function updateTimer() {
    const timerEl = document.getElementById('frictionTimer');
    const headerTimerEl = document.getElementById('headerTimer');

    if (!lastMessageTime || frictionLevel === 0) {
      timerEl.textContent = '';
      headerTimerEl.classList.remove('active');
      headerTimerEl.textContent = '';
      return;
    }

    const elapsed = Date.now() - lastMessageTime;
    const remaining = RESET_TIME - elapsed;

    if (remaining <= 0) {
      frictionLevel = 0;
      lastMessageTime = null;
      saveFrictionState();
      timerEl.textContent = 'ðŸŽ‰ Reset! Back to Level 1.';
      headerTimerEl.textContent = 'ðŸŽ‰ Level 1';
      if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
      setTimeout(function() { headerTimerEl.classList.remove('active'); }, 5000);
    } else {
      const timeStr = formatTimeRemaining(remaining);
      timerEl.textContent = 'â± Resets in ' + timeStr;
      headerTimerEl.textContent = 'L' + Math.min(frictionLevel + 1, 5) + ' Â· ' + timeStr;
      headerTimerEl.classList.add('active');
    }
  }

  function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    updateTimer();
    timerInterval = setInterval(updateTimer, 1000);
  }

  let headerTimerInterval = null;
  function startHeaderTimer() {
    if (headerTimerInterval) clearInterval(headerTimerInterval);
    updateTimer();
    headerTimerInterval = setInterval(updateTimer, 1000);
  }

  function getFrictionConfig() {
    const configs = [
      { rows: 1, length: 6 },
      { rows: 1, length: 10 },
      { rows: 1, length: 14 },
      { rows: 1, length: 18 },
      { rows: 2, length: 20 }
    ];
    return configs[Math.min(frictionLevel, 4)];
  }

  function showFriction(message) {
    if (lastMessageTime && (Date.now() - lastMessageTime > RESET_TIME)) {
      frictionLevel = 0;
      lastMessageTime = null;
      saveFrictionState();
    }

    state.pendingMessage = message;
    const config = getFrictionConfig();

    challenge1 = generateChallenge(config.length);
    frictionCode1.textContent = challenge1;
    frictionInput1.value = '';
    frictionInput1.classList.remove('success', 'error');

    const row2 = document.getElementById('frictionRow2');
    if (config.rows === 2) {
      challenge2 = generateChallenge(config.length);
      frictionCode2.textContent = challenge2;
      frictionInput2.value = '';
      frictionInput2.classList.remove('success', 'error');
      row2.style.display = 'block';
    } else {
      challenge2 = '';
      row2.style.display = 'none';
    }

    frictionUnlock.disabled = true;
    frictionUnlock.classList.remove('ready');
    frictionError.textContent = '';

    const subtitle = document.querySelector('.friction-subtitle');
    if (frictionLevel < 4) {
      subtitle.textContent = 'Level ' + (frictionLevel + 1) + ' of 5 â€” Type the code to send.';
    } else {
      subtitle.textContent = 'Level 5 of 5 â€” Maximum friction. Take a 2-hour break to reset.';
    }

    startTimer();
    frictionOverlay.classList.add('active');
    lockBodyScroll();
    document.addEventListener('touchmove', preventTouchMove, { passive: false });
    document.documentElement.style.setProperty('--kb', '0px');
    setTimeout(function() { frictionInput1.focus(); }, 10);
  }

  function hideFriction() {
    frictionOverlay.classList.remove('active');
    state.pendingMessage = null;
    if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
    document.removeEventListener('touchmove', preventTouchMove);
    unlockBodyScroll();
    startHeaderTimer();
    setTimeout(updateKeyboardOffset, 80);
    setTimeout(scrollChatToBottom, 100);
  }

  function checkFrictionInputs() {
    const config = getFrictionConfig();
    const match1 = frictionInput1.value === challenge1;
    const match2 = config.rows === 1 || frictionInput2.value === challenge2;

    frictionInput1.classList.toggle('success', frictionInput1.value && match1);
    frictionInput1.classList.toggle('error', frictionInput1.value && !match1);

    if (config.rows === 2) {
      frictionInput2.classList.toggle('success', frictionInput2.value && match2);
      frictionInput2.classList.toggle('error', frictionInput2.value && !match2);
    }

    if (match1 && match2) {
      frictionUnlock.disabled = false;
      frictionUnlock.classList.add('ready');
    } else {
      frictionUnlock.disabled = true;
      frictionUnlock.classList.remove('ready');
    }
    frictionError.textContent = '';
  }

  function handlePaste(e) {
    e.preventDefault();
    frictionError.textContent = 'No pasting â€” type it out!';
  }

  frictionInput1.addEventListener('input', checkFrictionInputs);
  frictionInput2.addEventListener('input', checkFrictionInputs);
  frictionInput1.addEventListener('paste', handlePaste);
  frictionInput2.addEventListener('paste', handlePaste);
  frictionInput1.addEventListener('drop', function(e) { e.preventDefault(); });
  frictionInput2.addEventListener('drop', function(e) { e.preventDefault(); });

  frictionCancel.addEventListener('click', hideFriction);

  frictionUnlock.addEventListener('click', function() {
    const wasMaxLevel = frictionLevel >= 4;
    if (frictionLevel < 4) frictionLevel++;
    lastMessageTime = Date.now();
    saveFrictionState();

    const timerEl = document.getElementById('frictionTimer');

    if (document.activeElement && typeof document.activeElement.blur === 'function') {
      document.activeElement.blur();
    }
    frictionInput1.blur();
    frictionInput2.blur();

    if (wasMaxLevel) {
      timerEl.textContent = 'ðŸ”„ Level 5 remains. Timer resets to 2 hours with each message.';
      const msgToSend = state.pendingMessage;  // Capture it here!
      setTimeout(function() {
        hideFriction();
        sendMessage(msgToSend);  // Use the captured value
      }, 2000);
    } else {
      hideFriction();
      sendMessage(state.pendingMessage);
    }
  });

  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission().catch(function() {});
  }

  loadFrictionState();

  // CHAT FUNCTIONS
  function addMessage(content, type) {
    const div = document.createElement('div');
    div.className = 'message message-' + type;
    div.textContent = content;
    chatMessages.appendChild(div);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  async function sendMessage(content) {
    if (!content?.trim()) return;  // Bail if null or empty after trim

    const model = modelSelect.value;
    const welcome = chatMessages.querySelector('.welcome-message');
    if (welcome) welcome.remove();

    addMessage(content, 'user');
    state.messages.push({ role: 'user', content: content });

    state.isProcessing = true;
    btnSend.disabled = true;

    typingIndicator.classList.add('active');
    chatMessages.appendChild(typingIndicator);
    chatMessages.scrollTop = chatMessages.scrollHeight;

    try {
      const response = await callBackend(model);
      state.messages.push({ role: 'assistant', content: response });
      addMessage(response, 'ai');
    } catch (error) {
      addMessage('Error: ' + error.message, 'error');
    } finally {
      state.isProcessing = false;
      btnSend.disabled = false;
      typingIndicator.classList.remove('active');
      requestAnimationFrame(scrollChatToBottom);
    }
  }

  async function callBackend(model) {
    const res = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ model: model, messages: state.messages })
    });

    if (!res.ok) {
      let errorMsg = 'Backend API error';
      try { const error = await res.json(); errorMsg = error.error || errorMsg; } catch (e) {}
      throw new Error(errorMsg);
    }

    const data = await res.json();
    return data.response;
  }

  // INPUT HANDLING
  messageInput.addEventListener('input', function() {
    messageInput.style.height = 'auto';
    messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
    requestAnimationFrame(scrollChatToBottom);
  });

  function handleSend() {
    const content = messageInput.value.trim();
    if (!content || state.isProcessing) return;
    messageInput.value = '';
    messageInput.style.height = 'auto';
    showFriction(content);
  }

  btnSend.addEventListener('click', handleSend);

  messageInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  });

  // iOS KEYBOARD
  function scrollChatToBottom() {
    if (!chatApp.classList.contains('active')) return;
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  function updateKeyboardOffset() {
    if (!window.visualViewport) return;
    const vv = window.visualViewport;
    const keyboardHeight = Math.max(0, window.innerHeight - vv.height - vv.offsetTop);
    const overlayOpen = frictionOverlay.classList.contains('active');
    document.documentElement.style.setProperty('--kb', overlayOpen ? '0px' : (keyboardHeight + 'px'));

    if (!overlayOpen && keyboardHeight > 0 && document.activeElement === messageInput) {
      requestAnimationFrame(function() {
        scrollChatToBottom();
        messageInput.scrollIntoView({ block: 'end', behavior: 'auto' });
      });
    }
  }

  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', updateKeyboardOffset);
    window.visualViewport.addEventListener('scroll', updateKeyboardOffset);
  }

  document.addEventListener('focusin', function(e) {
    if (e.target === messageInput) {
      setTimeout(updateKeyboardOffset, 50);
      setTimeout(scrollChatToBottom, 80);
    }
  });

  document.addEventListener('focusout', function(e) {
    if (e.target === messageInput) {
      setTimeout(function() {
        document.documentElement.style.setProperty('--kb', '0px');
        scrollChatToBottom();
      }, 80);
    }
  });

  updateKeyboardOffset();
</script>